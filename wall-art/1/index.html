<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Camera Preview with Overlay and Capture</title>
  <style>
    body, html {
      margin: 0; padding: 0; height: 100vh;
      font-family: Arial, sans-serif;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      user-select: none;
      color: white;
    }
    #previewCanvas {
      border-radius: 20px;
      box-shadow: 0 0 20px #7b2ff7aa;
      background: #222;
      cursor: grab;
      touch-action: none;
      display: block;
      width: 360px;
      height: 640px;
    }
    #controls {
      margin-top: 20px;
      display: flex;
      gap: 20px;
    }
    button {
      padding: 12px 24px;
      border-radius: 10px;
      border: none;
      font-weight: bold;
      color: #fff;
      background: linear-gradient(90deg, #5E60CE, #3A0CA3);
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(58,12,163,0.7);
      font-size: 16px;
      user-select: none;
    }
    button:hover {
      background: linear-gradient(90deg, #7209b7, #4361ee);
    }
    #loadingText {
      position: absolute;
      top: 15px;
      left: 15px;
      color: #fff;
      font-size: 14px;
      background: rgba(0,0,0,0.6);
      padding: 5px 10px;
      border-radius: 6px;
      display: none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="loadingText">Loading camera...</div>
  <canvas id="previewCanvas" width="700" height="1024" aria-label="Camera preview with overlay"></canvas>
  
  <div id="controls">
    <button id="switchCameraBtn" aria-label="Switch Camera">Reverse Camera</button>
    <button id="captureBtn" aria-label="Capture Picture">Capture</button>
  </div>

  <script>
    const canvas = document.getElementById('previewCanvas');
    const ctx = canvas.getContext('2d');
    const switchBtn = document.getElementById('switchCameraBtn');
    const captureBtn = document.getElementById('captureBtn');
    const loadingText = document.getElementById('loadingText');

    let stream = null;
    let usingFrontCamera = true;
    let video = null;
    let overlayImg = new Image();
    overlayImg.src = 'asset.png'; // Default overlay image path
    let isOverlayLoaded = false;

    // Overlay state for position, scale and rotation
    let overlayState = {
      x: canvas.width * 0.15,
      y: canvas.height * 0.2,
      scale: 1,
      rotation: 0,
      dragging: false,
      dragStartX: 0,
      dragStartY: 0,
      lastX: 0,
      lastY: 0,
    };

    function startCamera() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      video = document.createElement('video');
      video.autoplay = true;
      video.playsInline = true;
      video.muted = true;
      loadingText.style.display = 'block';

      const constraints = {
        video: { facingMode: usingFrontCamera ? 'user' : 'environment' },
        audio: false
      };

      navigator.mediaDevices.getUserMedia(constraints).then(_stream => {
        stream = _stream;
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          video.play();
          loadingText.style.display = 'none';
          requestAnimationFrame(drawLoop);
        };
      }).catch(err => {
        alert('Error accessing camera: ' + err.message);
        loadingText.style.display = 'none';
      });
    }

    function drawLoop() {
      if (!video || video.readyState !== 4) {
        requestAnimationFrame(drawLoop);
        return;
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw mirrored video for front camera
      ctx.save();
      if (usingFrontCamera) {
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
      }
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      ctx.restore();

      // Draw overlay image if loaded
      if (isOverlayLoaded) {
        ctx.save();
        let iw = overlayImg.width * overlayState.scale;
        let ih = overlayImg.height * overlayState.scale;
        let cx = overlayState.x + iw/2;
        let cy = overlayState.y + ih/2;
        ctx.translate(cx, cy);
        ctx.rotate(overlayState.rotation * Math.PI / 180);
        ctx.translate(-iw/2, -ih/2);
        ctx.drawImage(overlayImg, 0, 0, iw, ih);
        ctx.restore();
      }

      requestAnimationFrame(drawLoop);
    }

    overlayImg.onload = () => {
      isOverlayLoaded = true;
      overlayState.scale = (canvas.width * 0.7) / overlayImg.width; // scale overlay to 70% canvas width
      overlayState.x = canvas.width * 0.15;
      overlayState.y = canvas.height * 0.2;
    };

    // Utility functions for drag/touch
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }

    function pointInRotatedRect(px, py, rx, ry, rw, rh, angle) {
      const cx = rx + rw / 2;
      const cy = ry + rh / 2;
      const dx = px - cx;
      const dy = py - cy;
      const rad = -angle * Math.PI / 180;
      const rdx = dx * Math.cos(rad) - dy * Math.sin(rad);
      const rdy = dx * Math.sin(rad) + dy * Math.cos(rad);
      return rdx > -rw / 2 && rdx < rw / 2 && rdy > -rh / 2 && rdy < rh / 2;
    }

    let isDragging = false;

    canvas.addEventListener('mousedown', (e) => {
      if (!isOverlayLoaded) return;
      const pos = getMousePos(e);
      const ow = overlayImg.width * overlayState.scale;
      const oh = overlayImg.height * overlayState.scale;
      if (pointInRotatedRect(pos.x, pos.y, overlayState.x, overlayState.y, ow, oh, overlayState.rotation)) {
        isDragging = true;
        overlayState.dragStartX = pos.x;
        overlayState.dragStartY = pos.y;
        overlayState.lastX = overlayState.x;
        overlayState.lastY = overlayState.y;
        canvas.style.cursor = 'grabbing';
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const pos = getMousePos(e);
      overlayState.x = overlayState.lastX + (pos.x - overlayState.dragStartX);
      overlayState.y = overlayState.lastY + (pos.y - overlayState.dragStartY);
    });

    window.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        canvas.style.cursor = 'grab';
      }
    });

    // Touch equivalents
    canvas.addEventListener('touchstart', e => {
      if (!isOverlayLoaded) return;
      if (e.touches.length === 1) {
        const pos = getTouchPos(e.touches[0]);
        const ow = overlayImg.width * overlayState.scale;
        const oh = overlayImg.height * overlayState.scale;
        if (pointInRotatedRect(pos.x, pos.y, overlayState.x, overlayState.y, ow, oh, overlayState.rotation)) {
          isDragging = true;
          overlayState.dragStartX = pos.x;
          overlayState.dragStartY = pos.y;
          overlayState.lastX = overlayState.x;
          overlayState.lastY = overlayState.y;
          canvas.style.cursor = 'grabbing';
        }
      }
    }, { passive: false });

    window.addEventListener('touchmove', e => {
      if (!isDragging) return;
      e.preventDefault();
      const pos = getTouchPos(e.touches[0]);
      overlayState.x = overlayState.lastX + (pos.x - overlayState.dragStartX);
      overlayState.y = overlayState.lastY + (pos.y - overlayState.dragStartY);
    }, { passive: false });

    window.addEventListener('touchend', () => {
      if (isDragging) {
        isDragging = false;
        canvas.style.cursor = 'grab';
      }
    });

    function getTouchPos(touch) {
      const rect = canvas.getBoundingClientRect();
      return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
    }

    switchBtn.onclick = () => {
      usingFrontCamera = !usingFrontCamera;
      startCamera();
    };

    captureBtn.onclick = () => {
      canvas.toBlob(blob => {
        if (!blob) {
          alert('Capture failed: empty image.');
          return;
        }
        const url = URL.createObjectURL(blob);
        window.open(url, "_blank");
      }, 'image/png');
    };

    startCamera();
  </script>
</body>
</html>
