<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Responsive Camera Preview with Overlay</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: #000;
    user-select: none;
    overflow-x: hidden; /* default no horizontal scroll */
    overflow-y: hidden; /* will toggle in JS */
  }
  body {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #previewCanvas {
    background: #222;
    border-radius: 20px;
    cursor: grab;
    touch-action: none;
    box-shadow: 0 0 20px #7b2ff7aa;
    display: block;
    /* width and height controlled by JS */
  }
  #controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 15px;
    z-index: 10;
    background: rgba(0,0,0,0.4);
    padding: 10px 20px;
    border-radius: 12px;
  }
  button {
    padding: 12px 24px;
    font-size: 16px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-weight: bold;
    color: white;
    background: linear-gradient(90deg, #5E60CE, #3A0CA3);
    box-shadow: 0 4px 12px rgba(58,12,163,0.7);
    user-select: none;
    transition: background 0.3s ease;
  }
  button:hover {
    background: linear-gradient(90deg, #7209b7, #4361ee);
  }
  #loadingText {
    position: fixed;
    top: 20px;
    left: 20px;
    color: white;
    font-size: 16px;
    background: rgba(0,0,0,0.6);
    padding: 6px 12px;
    border-radius: 8px;
    z-index: 10;
    user-select: none;
    display: none;
  }
</style>
</head>
<body>

<div id="loadingText">Loading camera...</div>
<canvas id="previewCanvas" aria-label="Camera preview with overlay"></canvas>

<div id="controls">
  <button id="switchCameraBtn" aria-label="Switch Camera">Reverse Camera</button>
  <button id="captureBtn" aria-label="Capture Picture">Capture</button>
</div>

<script>
  const canvas = document.getElementById('previewCanvas');
  const ctx = canvas.getContext('2d');
  const switchBtn = document.getElementById('switchCameraBtn');
  const captureBtn = document.getElementById('captureBtn');
  const loadingText = document.getElementById('loadingText');

  let stream = null;
  let usingFrontCamera = true;
  let video = null;
  let overlayImg = new Image();
  overlayImg.src = 'asset.png'; // overlay PNG
  let isOverlayLoaded = false;

  // Overlay state for position, scale, rotation, drag data
  const overlayState = {
    x: null,
    y: null,
    scale: 1,
    rotation: 0,
    dragStartX: 0,
    dragStartY: 0,
    lastX: 0,
    lastY: 0,
  };

  // Device width breakpoint to separate mobile/tablet+desktop (can adjust as needed)
  const mobileMaxWidth = 768;

  // Resize canvas and control body overflow per device width and video aspect ratio
  function resizeCanvas() {
    if (!video || video.videoWidth === 0 || video.videoHeight === 0) return;

    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const videoAspect = video.videoWidth / video.videoHeight;

    // Mobile: constrain height to viewport height, width can overflow horizontally (hidden scroll)
    if (viewportWidth <= mobileMaxWidth) {
      // Height fixed to viewport height
      const canvasHeight = viewportHeight;
      const canvasWidth = canvasHeight * videoAspect;

      canvas.style.height = canvasHeight + 'px';
      canvas.style.width = canvasWidth + 'px';

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      // prevent scroll on y, allow overflow-x hidden
      document.body.style.overflowY = 'hidden';
      document.body.style.overflowX = 'hidden';

    } else {
      // Tablet/Desktop: constrain width to viewport width, height can overflow vertically (hidden scroll)
      const canvasWidth = viewportWidth;
      const canvasHeight = canvasWidth / videoAspect;

      canvas.style.width = canvasWidth + 'px';
      canvas.style.height = canvasHeight + 'px';

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      // prevent scroll on x, allow overflow-y hidden
      document.body.style.overflowX = 'hidden';
      document.body.style.overflowY = 'hidden';
    }

    // Initialize overlay position/scaling on first resize or if null
    if (overlayState.x === null || overlayState.y === null) {
      overlayState.scale = (canvas.width * 0.7) / overlayImg.width;
      overlayState.x = canvas.width * 0.15;
      overlayState.y = canvas.height * 0.2;
    }
  }

  function startCamera() {
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
    }
    video = document.createElement('video');
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true;
    loadingText.style.display = 'block';

    navigator.mediaDevices.getUserMedia({video: {facingMode: usingFrontCamera ? "user" : "environment"}, audio:false})
      .then(s => {
        stream = s;
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          video.play();
          loadingText.style.display = 'none';
          resizeCanvas();
          requestAnimationFrame(drawLoop);
        };
      })
      .catch(err => {
        alert("Error accessing camera: " + err.message);
        loadingText.style.display = 'none';
      });
  }

  function drawLoop() {
    if (!video || video.readyState !== 4) {
      requestAnimationFrame(drawLoop);
      return;
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Calculate letterbox style draw area for video to preserve aspect ratio inside canvas
    const videoAspect = video.videoWidth/video.videoHeight;
    const canvasAspect = canvas.width/canvas.height;
    let drawWidth, drawHeight, offsetX, offsetY;

    if (canvasAspect > videoAspect) {
      drawHeight = canvas.height;
      drawWidth = drawHeight * videoAspect;
      offsetX = (canvas.width - drawWidth)/2;
      offsetY = 0;
    } else {
      drawWidth = canvas.width;
      drawHeight = drawWidth / videoAspect;
      offsetX = 0;
      offsetY = (canvas.height - drawHeight)/2;
    }

    ctx.save();
    if (usingFrontCamera) {
      ctx.translate(canvas.width, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
    } else {
      ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
    }
    ctx.restore();

    if (isOverlayLoaded) {
      ctx.save();
      const iw = overlayImg.width * overlayState.scale;
      const ih = overlayImg.height * overlayState.scale;
      const cx = overlayState.x + iw/2;
      const cy = overlayState.y + ih/2;
      ctx.translate(cx, cy);
      ctx.rotate(overlayState.rotation * Math.PI/180);
      ctx.translate(-iw/2, -ih/2);
      ctx.drawImage(overlayImg, 0, 0, iw, ih);
      ctx.restore();
    }
    requestAnimationFrame(drawLoop);
  }

  overlayImg.onload = () => {
    isOverlayLoaded = true;
    resizeCanvas();  // recalc once overlay loaded to init overlay pos
  };

  // Overlay drag/touch utils
  let isDragging = false;

  function getPointerPos(evt) {
    const rect = canvas.getBoundingClientRect();
    if (evt.touches) {
      return { x: evt.touches[0].clientX - rect.left, y: evt.touches[0].clientY - rect.top };
    }
    return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
  }

  function pointInRotatedRect(px, py, rx, ry, rw, rh, angle) {
    const cx = rx + rw/2;
    const cy = ry + rh/2;
    const dx = px - cx;
    const dy = py - cy;
    const rad = -angle * Math.PI / 180;
    const rdx = dx * Math.cos(rad) - dy * Math.sin(rad);
    const rdy = dx * Math.sin(rad) + dy * Math.cos(rad);
    return rdx > -rw/2 && rdx < rw/2 && rdy > -rh/2 && rdy < rh/2;
  }

  canvas.addEventListener('mousedown', e => {
    if (!isOverlayLoaded) return;
    const pos = getPointerPos(e);
    const ow = overlayImg.width * overlayState.scale;
    const oh = overlayImg.height * overlayState.scale;
    if (pointInRotatedRect(pos.x, pos.y, overlayState.x, overlayState.y, ow, oh, overlayState.rotation)){
      isDragging = true;
      overlayState.dragStartX = pos.x;
      overlayState.dragStartY = pos.y;
      overlayState.lastX = overlayState.x;
      overlayState.lastY = overlayState.y;
      canvas.style.cursor = 'grabbing';
    }
  });
  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const pos = getPointerPos(e);
    overlayState.x = overlayState.lastX + (pos.x - overlayState.dragStartX);
    overlayState.y = overlayState.lastY + (pos.y - overlayState.dragStartY);
  });
  window.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      canvas.style.cursor = 'grab';
    }
  });

  canvas.addEventListener('touchstart', e => {
    if (!isOverlayLoaded) return;
    if(e.touches.length === 1){
      const pos = getPointerPos(e);
      const ow = overlayImg.width * overlayState.scale;
      const oh = overlayImg.height * overlayState.scale;
      if(pointInRotatedRect(pos.x, pos.y, overlayState.x, overlayState.y, ow, oh, overlayState.rotation)){
        isDragging = true;
        overlayState.dragStartX = pos.x;
        overlayState.dragStartY = pos.y;
        overlayState.lastX = overlayState.x;
        overlayState.lastY = overlayState.y;
        canvas.style.cursor = 'grabbing';
      }
    }
  }, {passive:false});

  window.addEventListener('touchmove', e => {
    if (!isDragging) return;
    e.preventDefault();
    const pos = getPointerPos(e);
    overlayState.x = overlayState.lastX + (pos.x - overlayState.dragStartX);
    overlayState.y = overlayState.lastY + (pos.y - overlayState.dragStartY);
  }, {passive:false});

  window.addEventListener('touchend', () => {
    if(isDragging){
      isDragging = false;
      canvas.style.cursor = 'grab';
    }
  });

  // Button logic
  switchBtn.addEventListener('click', () => {
    usingFrontCamera = !usingFrontCamera;
    startCamera();
  });

  captureBtn.addEventListener('click', () => {
    // Capture canvas as image excluding buttons
    canvas.toBlob(blob => {
      if(!blob){
        alert('Capture failed: empty image.');
        return;
      }
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank');
    }, 'image/png');
  });

  // Initialization
  resizeCanvas();
  startCamera();

  // Ensure resize always sets canvas size properly
  window.addEventListener('resize', () => {
    resizeCanvas();
  });
</script>

</body>
</html>
