<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Responsive Camera Preview with Overlay and Multi-Touch</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: #000;
    user-select: none;
    overflow-x: hidden; 
    overflow-y: hidden; 
  }
  body {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #previewCanvas {
    background: #222;
    border-radius: 20px;
    cursor: grab;
    touch-action: none;
    box-shadow: 0 0 20px #7b2ff7aa;
    display: block;
  }
  #controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 15px;
    z-index: 10;
    background: rgba(0,0,0,0.4);
    padding: 10px 20px;
    border-radius: 12px;
  }
  button {
    padding: 12px 24px;
    font-size: 16px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-weight: bold;
    color: white;
    background: linear-gradient(90deg, #5E60CE, #3A0CA3);
    box-shadow: 0 4px 12px rgba(58,12,163,0.7);
    user-select: none;
    transition: background 0.3s ease;
  }
  button:hover {
    background: linear-gradient(90deg, #7209b7, #4361ee);
  }
  #loadingText {
    position: fixed;
    top: 20px;
    left: 20px;
    color: white;
    font-size: 16px;
    background: rgba(0,0,0,0.6);
    padding: 6px 12px;
    border-radius: 8px;
    z-index: 10;
    user-select: none;
    display: none;
  }
</style>
</head>
<body>

<div id="loadingText">Loading camera...</div>
<canvas id="previewCanvas" aria-label="Camera preview with overlay"></canvas>

<div id="controls">
  <button id="switchCameraBtn" aria-label="Switch Camera">Reverse Camera</button>
  <button id="captureBtn" aria-label="Capture Picture">Capture</button>
</div>

<script>
  const canvas = document.getElementById('previewCanvas');
  const ctx = canvas.getContext('2d');
  const switchBtn = document.getElementById('switchCameraBtn');
  const captureBtn = document.getElementById('captureBtn');
  const loadingText = document.getElementById('loadingText');

  let stream = null;
  let usingFrontCamera = true;
  let video = null;
  let overlayImg = new Image();
  overlayImg.src = 'asset.png'; // overlay PNG path
  let isOverlayLoaded = false;

  const overlayState = {
    x: null,
    y: null,
    scale: 1,
    rotation: 0,
    dragStartX: 0,
    dragStartY: 0,
    lastX: 0,
    lastY: 0,
  };

  function resizeCanvas() {
    if (!video || video.videoWidth === 0 || video.videoHeight === 0) return;

    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const videoAspect = video.videoWidth / video.videoHeight;

    if (vw <= 768) { // mobile: height fixed, width may overflow invisible
      const ch = vh;
      const cw = ch * videoAspect;
      canvas.width = cw;
      canvas.height = ch;
      canvas.style.width = cw + 'px';
      canvas.style.height = ch + 'px';
      document.body.style.overflowX = 'hidden';
      document.body.style.overflowY = 'hidden';

    } else { // tablet/desktop: width fixed, height may overflow invisible
      const cw = vw;
      const ch = cw / videoAspect;
      canvas.width = cw;
      canvas.height = ch;
      canvas.style.width = cw + 'px';
      canvas.style.height = ch + 'px';
      document.body.style.overflowX = 'hidden';
      document.body.style.overflowY = 'hidden';
    }

    if (overlayState.x === null || overlayState.y === null) {
      overlayState.scale = (canvas.width * 0.7) / overlayImg.width;
      overlayState.x = canvas.width * 0.15;
      overlayState.y = canvas.height * 0.2;
    }
  }

  function startCamera() {
    if (stream) stream.getTracks().forEach(track => track.stop());
    video = document.createElement('video');
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true;
    loadingText.style.display = 'block';

    navigator.mediaDevices.getUserMedia({video: {facingMode: usingFrontCamera ? 'user' : 'environment'}, audio:false})
      .then(s => {
        stream = s;
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          video.play();
          loadingText.style.display = 'none';
          resizeCanvas();
          requestAnimationFrame(drawLoop);
        };
      })
      .catch(err => {
        alert('Error accessing camera: ' + err.message);
        loadingText.style.display = 'none';
      });
  }

  function drawLoop() {
    if (!video || video.readyState !== 4) {
      requestAnimationFrame(drawLoop);
      return;
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const vA = video.videoWidth / video.videoHeight;
    const cA = canvas.width / canvas.height;

    let drawW, drawH, offsetX, offsetY;

    if (cA > vA) {
      drawH = canvas.height;
      drawW = drawH * vA;
      offsetX = (canvas.width - drawW)/2;
      offsetY = 0;
    } else {
      drawW = canvas.width;
      drawH = drawW / vA;
      offsetX = 0;
      offsetY = (canvas.height - drawH)/2;
    }

    ctx.save();
    if (usingFrontCamera) {
      ctx.translate(canvas.width, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(video, offsetX, offsetY, drawW, drawH);
    } else {
      ctx.drawImage(video, offsetX, offsetY, drawW, drawH);
    }
    ctx.restore();

    if (isOverlayLoaded) {
      ctx.save();
      const iw = overlayImg.width * overlayState.scale;
      const ih = overlayImg.height * overlayState.scale;
      const cx = overlayState.x + iw/2;
      const cy = overlayState.y + ih/2;
      ctx.translate(cx, cy);
      ctx.rotate(overlayState.rotation * Math.PI / 180);
      ctx.translate(-iw/2, -ih/2);
      ctx.drawImage(overlayImg, 0, 0, iw, ih);
      ctx.restore();
    }

    requestAnimationFrame(drawLoop);
  }

  overlayImg.onload = () => {
    isOverlayLoaded = true;
    resizeCanvas();
  };

  // --- Multi-touch overlay control ---

  let isDragging = false;
  let initialDistance = 0;
  let initialAngle = 0;
  let lastScale = 1;
  let lastRotation = 0;
  let isTouchDragging = false;
  let lastTouchCenter = {x:0, y:0};

  function getPointerPos(evt){
    const rect = canvas.getBoundingClientRect();
    if(evt.touches) {
      return {x: evt.touches[0].clientX - rect.left, y: evt.touches[0].clientY - rect.top};
    }
    return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};
  }

  function pointInRotatedRect(px, py, rx, ry, rw, rh, angle){
    const cx = rx + rw/2;
    const cy = ry + rh/2;
    const dx = px - cx;
    const dy = py - cy;
    const rad = -angle * Math.PI/180;
    const rdx = dx * Math.cos(rad) - dy * Math.sin(rad);
    const rdy = dx * Math.sin(rad) + dy * Math.cos(rad);
    return rdx > -rw/2 && rdx < rw/2 && rdy > -rh/2 && rdy < rh/2;
  }

  function getDistance(t1,t2){
    return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
  }
  function getAngle(t1,t2){
    return Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX) * 180 / Math.PI;
  }
  function getTouchCenter(t1,t2){
    return {x: (t1.clientX + t2.clientX)/2 - canvas.getBoundingClientRect().left, y: (t1.clientY + t2.clientY)/2 - canvas.getBoundingClientRect().top};
  }

  canvas.addEventListener('touchstart', e => {
    if(!isOverlayLoaded) return;
    if(e.touches.length === 1){
      const pos = getPointerPos(e);
      const ow = overlayImg.width * overlayState.scale;
      const oh = overlayImg.height * overlayState.scale;
      if(pointInRotatedRect(pos.x, pos.y, overlayState.x, overlayState.y, ow, oh, overlayState.rotation)){
        isTouchDragging = true;
        overlayState.dragStartX = pos.x;
        overlayState.dragStartY = pos.y;
        overlayState.lastX = overlayState.x;
        overlayState.lastY = overlayState.y;
        canvas.style.cursor = 'grabbing';
      }
      initialDistance = 0; // reset multi touch vars
      initialAngle = 0;
      lastScale = overlayState.scale;
      lastRotation = overlayState.rotation;
    } else if(e.touches.length === 2){
      isTouchDragging = false;
      initialDistance = getDistance(e.touches[0], e.touches[1]);
      initialAngle = getAngle(e.touches[0], e.touches[1]);
      lastScale = overlayState.scale;
      lastRotation = overlayState.rotation;
      lastTouchCenter = getTouchCenter(e.touches[0], e.touches[1]);
    }
  }, {passive:false});

  canvas.addEventListener('touchmove', e => {
    if(!isOverlayLoaded) return;
    e.preventDefault();
    if(e.touches.length === 1 && isTouchDragging){
      const pos = getPointerPos(e);
      overlayState.x = overlayState.lastX + (pos.x - overlayState.dragStartX);
      overlayState.y = overlayState.lastY + (pos.y - overlayState.dragStartY);
    } else if(e.touches.length === 2){
      const currDistance = getDistance(e.touches[0], e.touches[1]);
      const currAngle = getAngle(e.touches[0], e.touches[1]);
      const scaleChange = currDistance / initialDistance;
      overlayState.scale = lastScale * scaleChange;

      const rotationChange = currAngle - initialAngle;
      overlayState.rotation = lastRotation + rotationChange;

      const currCenter = getTouchCenter(e.touches[0], e.touches[1]);
      const dx = currCenter.x - lastTouchCenter.x;
      const dy = currCenter.y - lastTouchCenter.y;

      overlayState.x += dx;
      overlayState.y += dy;

      lastTouchCenter = currCenter;
    }
  }, {passive:false});

  canvas.addEventListener('touchend', e => {
    if(e.touches.length === 0){
      isTouchDragging = false;
      canvas.style.cursor = 'grab';
    }
  }, {passive:false});

  // Mouse drag fallback for desktop
  canvas.addEventListener('mousedown', e => {
    if(!isOverlayLoaded) return;
    const pos = getPointerPos(e);
    const ow = overlayImg.width * overlayState.scale;
    const oh = overlayImg.height * overlayState.scale;
    if(pointInRotatedRect(pos.x, pos.y, overlayState.x, overlayState.y, ow, oh, overlayState.rotation)){
      isDragging = true;
      overlayState.dragStartX = pos.x;
      overlayState.dragStartY = pos.y;
      overlayState.lastX = overlayState.x;
      overlayState.lastY = overlayState.y;
      canvas.style.cursor = 'grabbing';
    }
  });
  window.addEventListener('mousemove', e => {
    if(!isDragging) return;
    const pos = getPointerPos(e);
    overlayState.x = overlayState.lastX + (pos.x - overlayState.dragStartX);
    overlayState.y = overlayState.lastY + (pos.y - overlayState.dragStartY);
  });
  window.addEventListener('mouseup', e => {
    if(isDragging){
      isDragging = false;
      canvas.style.cursor = 'grab';
    }
  });

  switchBtn.addEventListener('click', () => {
    usingFrontCamera = !usingFrontCamera;
    startCamera();
  });

  captureBtn.addEventListener('click', () => {
    if(!video || video.videoWidth === 0 || video.videoHeight === 0) {
      alert('Video not ready');
      return;
    }
    const videoAspect = video.videoWidth / video.videoHeight;
    const canvasAspect = canvas.width / canvas.height;

    let drawWidth, drawHeight, offsetX, offsetY;
    if(canvasAspect > videoAspect){
      drawHeight = canvas.height;
      drawWidth = drawHeight * videoAspect;
      offsetX = (canvas.width - drawWidth)/2;
      offsetY = 0;
    } else {
      drawWidth = canvas.width;
      drawHeight = drawWidth / videoAspect;
      offsetX = 0;
      offsetY = (canvas.height - drawHeight)/2;
    }

    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = drawWidth;
    offscreenCanvas.height = drawHeight;
    const offctx = offscreenCanvas.getContext('2d');

    offctx.save();
    if(usingFrontCamera){
      offctx.translate(drawWidth, 0);
      offctx.scale(-1,1);
    }
    offctx.drawImage(video, 0,0, video.videoWidth, video.videoHeight, 0,0, drawWidth, drawHeight);
    offctx.restore();

    const overlayX = overlayState.x - offsetX;
    const overlayY = overlayState.y - offsetY;
    const ow = overlayImg.width * overlayState.scale;
    const oh = overlayImg.height * overlayState.scale;

    offctx.save();
    offctx.translate(overlayX + ow/2, overlayY + oh/2);
    offctx.rotate(overlayState.rotation * Math.PI/180);
    offctx.translate(-ow/2, -oh/2);
    offctx.drawImage(overlayImg, 0,0, ow, oh);
    offctx.restore();

    offscreenCanvas.toBlob(blob => {
      if(!blob){
        alert('Capture failed: empty image.');
        return;
      }
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank');
    }, 'image/png');
  });

  // Initialize
  window.addEventListener('resize', () => {
    if(video && video.videoWidth) resizeCanvas();
  });

  resizeCanvas();
  startCamera();

</script>
</body>
</html>
