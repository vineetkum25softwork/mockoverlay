<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Full Screen Camera with Overlay and Capture</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%; width: 100%;
    overflow: hidden;
    background: black;
    user-select: none;
  }
  #previewCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    display: block;
    background: #222;
  }
  #controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 15px;
    z-index: 10;
    background: rgba(0,0,0,0.4);
    padding: 10px 20px;
    border-radius: 12px;
  }
  button {
    padding: 12px 24px;
    font-size: 16px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-weight: bold;
    color: white;
    background: linear-gradient(90deg, #5E60CE, #3A0CA3);
    box-shadow: 0 4px 12px rgba(58,12,163,0.7);
    user-select: none;
    transition: background 0.3s ease;
  }
  button:hover {
    background: linear-gradient(90deg, #7209b7, #4361ee);
  }
  #loadingText {
    position: fixed;
    top: 20px;
    left: 20px;
    color: white;
    font-size: 16px;
    background: rgba(0,0,0,0.6);
    padding: 6px 12px;
    border-radius: 8px;
    z-index: 10;
    user-select: none;
  }
</style>
</head>
<body>

<div id="loadingText">Loading camera...</div>

<canvas id="previewCanvas"></canvas>

<div id="controls">
  <button id="switchCameraBtn" aria-label="Switch Camera">Reverse Camera</button>
  <button id="captureBtn" aria-label="Capture Picture">Capture</button>
</div>

<script>
  const canvas = document.getElementById('previewCanvas');
  const ctx = canvas.getContext('2d');
  const switchBtn = document.getElementById('switchCameraBtn');
  const captureBtn = document.getElementById('captureBtn');
  const loadingText = document.getElementById('loadingText');

  let stream = null;
  let usingFrontCamera = true;
  let video = null;
  let overlayImg = new Image();
  overlayImg.src = 'asset.png'; // overlay PNG path
  let isOverlayLoaded = false;

  // Overlay state
  let overlayState = {
    x: null,
    y: null,
    scale: 1,
    rotation: 0,
    dragStartX: 0,
    dragStartY: 0,
    lastX: 0,
    lastY: 0,
  };

  // Resize canvas to fill viewport and update overlay position accordingly
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    if (overlayState.x === null || overlayState.y === null) {
      overlayState.scale = (canvas.width * 0.7) / overlayImg.width;
      overlayState.x = canvas.width * 0.15;
      overlayState.y = canvas.height * 0.2;
    }
  }
  window.addEventListener('resize', resizeCanvas);

  function startCamera() {
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
    }
    video = document.createElement('video');
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true;
    loadingText.style.display = 'block';

    const constraints = {
      video: { facingMode: usingFrontCamera ? 'user' : 'environment' },
      audio: false
    };

    navigator.mediaDevices.getUserMedia(constraints)
      .then(_stream => {
        stream = _stream;
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          video.play();
          loadingText.style.display = 'none';
          resizeCanvas();
          requestAnimationFrame(drawLoop);
        };
      })
      .catch(err => {
        alert('Error accessing camera: ' + err.message);
        loadingText.style.display = 'none';
      });
  }

  function drawLoop() {
    if (!video || video.readyState !== 4) {
      requestAnimationFrame(drawLoop);
      return;
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Calculate aspect ratio and letterboxing
    const videoAR = video.videoWidth / video.videoHeight;
    const canvasAR = canvas.width / canvas.height;

    let drawWidth, drawHeight, offsetX, offsetY;
    if (canvasAR > videoAR) {
      drawHeight = canvas.height;
      drawWidth = drawHeight * videoAR;
      offsetX = (canvas.width - drawWidth) / 2;
      offsetY = 0;
    } else {
      drawWidth = canvas.width;
      drawHeight = drawWidth / videoAR;
      offsetX = 0;
      offsetY = (canvas.height - drawHeight) / 2;
    }

    ctx.save();
    if (usingFrontCamera) {
      ctx.translate(canvas.width, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
    } else {
      ctx.drawImage(video, offsetX, offsetY, drawWidth, drawHeight);
    }
    ctx.restore();

    if (isOverlayLoaded) {
      ctx.save();
      const iw = overlayImg.width * overlayState.scale;
      const ih = overlayImg.height * overlayState.scale;
      const cx = overlayState.x + iw / 2;
      const cy = overlayState.y + ih / 2;
      ctx.translate(cx, cy);
      ctx.rotate(overlayState.rotation * Math.PI / 180);
      ctx.translate(-iw / 2, -ih / 2);
      ctx.drawImage(overlayImg, 0, 0, iw, ih);
      ctx.restore();
    }

    requestAnimationFrame(drawLoop);
  }

  overlayImg.onload = () => {
    isOverlayLoaded = true;
    resizeCanvas();
  };

  // Drag logic for overlay
  let isDragging = false;

  function getPointerPos(evt) {
    const rect = canvas.getBoundingClientRect();
    if (evt.touches) {
      return {
        x: evt.touches[0].clientX - rect.left,
        y: evt.touches[0].clientY - rect.top
      };
    }
    return {
      x: evt.clientX - rect.left,
      y: evt.clientY - rect.top
    };
  }

  function pointInRotatedRect(px, py, rx, ry, rw, rh, angle) {
    const cx = rx + rw/2;
    const cy = ry + rh/2;
    const dx = px - cx;
    const dy = py - cy;
    const rad = -angle * Math.PI/180;
    const rdx = dx * Math.cos(rad) - dy * Math.sin(rad);
    const rdy = dx * Math.sin(rad) + dy * Math.cos(rad);
    return rdx > -rw/2 && rdx < rw/2 && rdy > -rh/2 && rdy < rh/2;
  }

  canvas.addEventListener('mousedown', e => {
    if (!isOverlayLoaded) return;
    const pos = getPointerPos(e);
    const ow = overlayImg.width * overlayState.scale;
    const oh = overlayImg.height * overlayState.scale;
    if (pointInRotatedRect(pos.x, pos.y, overlayState.x, overlayState.y, ow, oh, overlayState.rotation)) {
      isDragging = true;
      overlayState.dragStartX = pos.x;
      overlayState.dragStartY = pos.y;
      overlayState.lastX = overlayState.x;
      overlayState.lastY = overlayState.y;
      canvas.style.cursor = 'grabbing';
    }
  });

  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const pos = getPointerPos(e);
    overlayState.x = overlayState.lastX + (pos.x - overlayState.dragStartX);
    overlayState.y = overlayState.lastY + (pos.y - overlayState.dragStartY);
  });

  window.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      canvas.style.cursor = 'grab';
    }
  });

  canvas.addEventListener('touchstart', e => {
    if (!isOverlayLoaded) return;
    if (e.touches.length === 1) {
      const pos = getPointerPos(e);
      const ow = overlayImg.width * overlayState.scale;
      const oh = overlayImg.height * overlayState.scale;
      if (pointInRotatedRect(pos.x, pos.y, overlayState.x, overlayState.y, ow, oh, overlayState.rotation)) {
        isDragging = true;
        overlayState.dragStartX = pos.x;
        overlayState.dragStartY = pos.y;
        overlayState.lastX = overlayState.x;
        overlayState.lastY = overlayState.y;
        canvas.style.cursor = 'grabbing';
      }
    }
  }, { passive: false });

  window.addEventListener('touchmove', e => {
    if (!isDragging) return;
    e.preventDefault();
    const pos = getPointerPos(e);
    overlayState.x = overlayState.lastX + (pos.x - overlayState.dragStartX);
    overlayState.y = overlayState.lastY + (pos.y - overlayState.dragStartY);
  }, { passive: false });

  window.addEventListener('touchend', () => {
    if (isDragging) {
      isDragging = false;
      canvas.style.cursor = 'grab';
    }
  });

  // Switch camera button logic
  switchBtn.addEventListener('click', () => {
    usingFrontCamera = !usingFrontCamera;
    startCamera();
  });

  // Capture button opens new tab with image of canvas content (camera + overlay only)
  captureBtn.addEventListener('click', () => {
    canvas.toBlob(blob => {
      if (!blob) {
        alert('Capture failed: empty image.');
        return;
      }
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank');
    }, 'image/png');
  });

  // Init
  resizeCanvas();
  startCamera();
</script>
</body>
</html>
