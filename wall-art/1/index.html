<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Responsive Camera Preview with Overlay and Desktop Demo</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      background: #f4e1f7;
    }


    body {
      display: flex;


    }


    /* Containers */
    #camera-container {
      height: 100vh;
      width: 100vw;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }


    #desktop-container {
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }


    #camera-container.active,
    #desktop-container.active {
      display: flex;
    }


    /* Camera container styling */
    #previewCanvas {
      background: #373737;
      cursor: grab;
      touch-action: none;
      display: block;
      max-width: 100vw;
      max-height: 100vh;
    }


    #controls {
      margin-top: 15px;
      display: flex;
      gap: 15px;
      width: 100%;
      max-width: 400px;
      justify-content: space-around;
    }


    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-weight: bold;
      user-select: none;
    }


    #switchCameraBtn {
      color: rgb(31, 31, 31);
      background-color: rgb(242, 248, 253);
    }


    #switchCameraBtn:hover {
      background: #d9e8fa;
    }


    #captureBtn {
      color: white;
      background-image: linear-gradient(90deg, #F72585 0%, #B5179E 100%);
    }


    #captureBtn:hover {
      filter: brightness(1.1);
    }


    #loadingText {
      position: absolute;
      top: 46%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      padding: 8px 16px;
      user-select: none;
      z-index: 20;
      display: none;
    }


    #camera-container {
      position: relative;
      /* For loading text absolute to work inside */
    }



    /* Desktop container styling */
    #desktop-container {
      padding: 20px;
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      flex-direction: row;
      gap: 20px;
    }


    .left-col-6 {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding-left: 8vw;
    }


    .right-col-6 {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding-right: 8vw;
    }


    #desktop-message {
      font-size: 1.8rem;
      margin-bottom: 40px;
      max-width: 90%;
      color: #4a148c;
      /* deeper violet */
    }


    #qr-placeholder {
      width: 180px;
      height: 180px;
      border: 4px dashed #b5179e;
      border-radius: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #b5179e;
      font-weight: bold;
      font-size: 1.1rem;
      user-select: none;
      margin-top: 10px;
    }


    /* Phone mockup */
    #phone {
      width: 300px;
      height: 600px;
      border: 15px solid #333;
      border-radius: 40px;
      overflow: hidden;
      position: relative;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      background: #000;
    }


    #imageContainer {
      position: absolute;
      top: 0;
      left: 0;
      height: 110vh;
      width: 100%;
      transition: transform 8s ease-in-out;
    }


    #imageContainer img {
      height: 100%;
      width: 130%;
      object-fit: cover;
      display: block;
      transition: transform 3s ease-in-out;
      transform-origin: center center;
    }


    #wallArt {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background-position: center;
      background-repeat: no-repeat;
      background-size: contain;
      transform: scale(0.4) translateY(-20%);
      transform-origin: center center;
      transition: transform 2s ease-in-out;
    }
  </style>
</head>


<body>


  <!-- Camera container (visible on phone/tablet) -->
  <div id="camera-container" class="active">
    <div id="loadingText">Loading camera...</div>
    <canvas id="previewCanvas" aria-label="Camera preview with overlay"></canvas>
    <div id="controls">
      <button id="switchCameraBtn" aria-label="Switch Camera"></button>
      <button id="captureBtn" aria-label="Capture Picture">Capture</button>
    </div>
  </div>


  <!-- Desktop container with two columns -->
  <div id="desktop-container">
    <div class="left-col-6" id="col-6-1">
      <div id="desktop-message">
        Please use phone or tablet for better experience.
      </div>
      <div id="qr-placeholder">QR Code here</div>
    </div>
    <div class="right-col-6" id="col-6-2">
      <div id="phone">
        <div id="imageContainer">
          <img id="bedroomImage"
            src="https://www.shutterstock.com/image-illustration/interior-modern-bedroom-beige-walls-600nw-2387252829.jpg"
            alt="Bedroom" />
        </div>
        <div id="wallArt"></div>
      </div>
    </div>
  </div>


  <script>
    // Desktop phone mockup wall art setup
    const bedroomImage = document.getElementById('bedroomImage');
    const wallArtDiv = document.getElementById('wallArt');
    const imageContainer = document.getElementById('imageContainer');


    const wallArtSrc = 'asset.png'; // your overlay
    wallArtDiv.style.backgroundImage = `url(${wallArtSrc})`;


    let toLeft = true;
    let step = 0;
    let paused = false;


    function slideImage() {
      if (paused) return;
      if (toLeft) {
        imageContainer.style.transform = "translateX(-100px)";
      } else {
        imageContainer.style.transform = "translateX(0)";
      }
      toLeft = !toLeft;
    }


    function animateWallArt() {
      if (paused) return;
      switch (step) {
        case 0: wallArtDiv.style.transform = "scale(0.6) translateY(-20%)"; break;
        case 1: wallArtDiv.style.transform = "scale(0.5) translateY(-20%)"; break;
        case 2: wallArtDiv.style.transform = "scale(0.55) translateY(-20%)"; break;
        case 3: wallArtDiv.style.transform = "scale(0.5) translateY(-20%)"; break;
        case 4: wallArtDiv.style.transform = "scale(0.45) translateY(-22%)"; break;
        case 5: wallArtDiv.style.transform = "scale(0.4) translateY(-20%)"; break;
        case 6: wallArtDiv.style.transform = "scale(0.5) translateY(-18%)"; break;
        default: wallArtDiv.style.transform = "scale(0.4) translateY(-20%)"; break;
      }
      step = (step + 1) % 10;
    }


    function startAnimations() {
      slideImage();
      animateWallArt();
      setInterval(slideImage, 5000);
      setInterval(animateWallArt, 5000);
    }


    setTimeout(startAnimations, 2500);



    // Camera related code for phone/tablet
    const cameraContainer = document.getElementById('camera-container');
    const desktopContainer = document.getElementById('desktop-container');
    const canvas = document.getElementById('previewCanvas');
    const ctx = canvas.getContext('2d');
    const switchBtn = document.getElementById('switchCameraBtn');
    const captureBtn = document.getElementById('captureBtn');
    const loadingText = document.getElementById('loadingText');


    let stream = null;
    let usingFrontCamera = false; // default back camera on phone/tablet
    let video = null;
    let overlayImage = new Image();
    overlayImage.src = 'asset.png';
    let isOverlayLoaded = false;


    const overlayState = {
      x: null,
      y: null,
      scale: 1,
      rotation: 0,
      dragStartX: 0,
      dragStartY: 0,
      lastX: 0,
      lastY: 0,
    };


    function detectDeviceAndToggleContainers() {
      if (window.innerWidth <= 1024) {
        // Phone/tablet
        cameraContainer.classList.add('active');
        desktopContainer.classList.remove('active');
        usingFrontCamera = false; // back cam default
        document.body.style.background = '#464646'; // dark grey background
        updateCameraButtonText();
        startCamera();
      } else {
        // Desktop
        cameraContainer.classList.remove('active');
        desktopContainer.classList.add('active');
        document.body.style.background = '#f4e1f7'; // very light violet-pink background
        stopCameraStream();
      }
    }


    function stopCameraStream() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
    }


    function updateCameraButtonText() {
      switchBtn.textContent = usingFrontCamera ? 'Back Camera' : 'Front Camera';
    }


    function resizeCanvas() {
      if (!video || video.videoWidth === 0) return;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const vA = video.videoWidth / video.videoHeight;


      if (vw <= 768) {
        const ch = vh;
        const cw = ch * vA;
        canvas.width = cw;
        canvas.height = ch;
        canvas.style.width = cw + 'px';
        canvas.style.height = ch + 'px';
        document.body.style.overflowX = 'hidden';
        document.body.style.overflowY = 'hidden';
      } else {
        const cw = vw;
        const ch = cw / vA;
        canvas.width = cw;
        canvas.height = ch;
        canvas.style.width = cw + 'px';
        canvas.style.height = ch + 'px';
        document.body.style.overflowX = 'hidden';
        document.body.style.overflowY = 'hidden';
      }


      if (overlayState.x === null || overlayState.y === null) {
        overlayState.scale = (canvas.width * 0.7) / overlayImage.width;
        overlayState.x = canvas.width * 0.15;
        overlayState.y = canvas.height * 0.2;
      }
    }


    function startCamera() {
      if (stream) stream.getTracks().forEach(t => t.stop());
      video = document.createElement('video');
      video.autoplay = true;
      video.playsInline = true;
      video.muted = true;
      loadingText.style.display = 'block';


      navigator.mediaDevices.getUserMedia({
        video: { facingMode: usingFrontCamera ? 'user' : 'environment' },
        audio: false
      }).then(s => {
        stream = s;
        video.srcObject = s;
        video.onloadedmetadata = () => {
          video.play();
          loadingText.style.display = 'none';
          resizeCanvas();
          requestAnimationFrame(drawLoop);
        };
      }).catch(e => {
        alert("Camera access denied or unavailable.");
        loadingText.style.display = 'none';
      });
    }


    function drawLoop() {
      if (!video || video.readyState !== 4) {
        requestAnimationFrame(drawLoop);
        return;
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);


      const vA = video.videoWidth / video.videoHeight;
      const cA = canvas.width / canvas.height;


      let drawW, drawH, offsetX, offsetY;
      if (cA > vA) {
        drawH = canvas.height;
        drawW = drawH * vA;
        offsetX = (canvas.width - drawW) / 2;
        offsetY = 0;
      } else {
        drawW = canvas.width;
        drawH = drawW / vA;
        offsetX = 0;
        offsetY = (canvas.height - drawH) / 2;
      }


      ctx.save();
      if (usingFrontCamera) {
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(video, offsetX, offsetY, drawW, drawH);
      } else {
        ctx.drawImage(video, offsetX, offsetY, drawW, drawH);
      }
      ctx.restore();


      if (isOverlayLoaded) {
        ctx.save();
        const iw = overlayImage.width * overlayState.scale;
        const ih = overlayImage.height * overlayState.scale;
        const cx = overlayState.x + iw / 2;
        const cy = overlayState.y + ih / 2;
        ctx.translate(cx, cy);
        ctx.rotate(overlayState.rotation * Math.PI / 180);
        ctx.translate(-iw / 2, -ih / 2);
        ctx.drawImage(overlayImage, 0, 0, iw, ih);
        ctx.restore();
      }


      requestAnimationFrame(drawLoop);
    }


    overlayImage.onload = () => {
      isOverlayLoaded = true;
      resizeCanvas();
    };


    // --- UPDATED MOVING IMAGE OVERLAY LOGIC FROM SECOND CODE ---


    let isDragging = false;
    let initialDistance = 0;
    let initialAngle = 0;
    let lastScale = 1;
    let lastRotation = 0;
    let isTouchDragging = false;
    let lastTouchCenter = { x: 0, y: 0 };


    function getPointerPos(evt) {
      const rect = canvas.getBoundingClientRect();
      if (evt.touches) {
        return { x: evt.touches[0].clientX - rect.left, y: evt.touches[0].clientY - rect.top };
      }
      return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }


    function pointInRotatedRect(px, py, rx, ry, rw, rh, angle) {
      const cx = rx + rw / 2;
      const cy = ry + rh / 2;
      const dx = px - cx;
      const dy = py - cy;
      const rad = -angle * Math.PI / 180;
      const rdx = dx * Math.cos(rad) - dy * Math.sin(rad);
      const rdy = dx * Math.sin(rad) + dy * Math.cos(rad);
      return rdx > -rw / 2 && rdx < rw / 2 && rdy > -rh / 2 && rdy < rh / 2;
    }


    function getDistance(t1, t2) {
      return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    }
    function getAngle(t1, t2) {
      return Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX) * 180 / Math.PI;
    }
    function getTouchCenter(t1, t2) {
      return { x: (t1.clientX + t2.clientX) / 2 - canvas.getBoundingClientRect().left, y: (t1.clientY + t2.clientY) / 2 - canvas.getBoundingClientRect().top };
    }


    canvas.addEventListener('touchstart', e => {
      if (!isOverlayLoaded) return;
      if (e.touches.length === 1) {
        const pos = getPointerPos(e);
        const ow = overlayImage.width * overlayState.scale;
        const oh = overlayImage.height * overlayState.scale;
        if (pointInRotatedRect(pos.x, pos.y, overlayState.x, overlayState.y, ow, oh, overlayState.rotation)) {
          isTouchDragging = true;
          overlayState.dragStartX = pos.x;
          overlayState.dragStartY = pos.y;
          overlayState.lastX = overlayState.x;
          overlayState.lastY = overlayState.y;
          canvas.style.cursor = 'grabbing';
        }
        initialDistance = 0; // reset multi touch vars
        initialAngle = 0;
        lastScale = overlayState.scale;
        lastRotation = overlayState.rotation;
      } else if (e.touches.length === 2) {
        isTouchDragging = false;
        initialDistance = getDistance(e.touches[0], e.touches[1]);
        initialAngle = getAngle(e.touches[0], e.touches[1]);
        lastScale = overlayState.scale;
        lastRotation = overlayState.rotation;
        lastTouchCenter = getTouchCenter(e.touches[0], e.touches[1]);
      }
    }, { passive: false });


    canvas.addEventListener('touchmove', e => {
      if (!isOverlayLoaded) return;
      e.preventDefault();
      if (e.touches.length === 1 && isTouchDragging) {
        const pos = getPointerPos(e);
        overlayState.x = overlayState.lastX + (pos.x - overlayState.dragStartX);
        overlayState.y = overlayState.lastY + (pos.y - overlayState.dragStartY);
      } else if (e.touches.length === 2) {
        const currDistance = getDistance(e.touches[0], e.touches[1]);
        const currAngle = getAngle(e.touches[0], e.touches[1]);
        const scaleChange = currDistance / initialDistance;
        overlayState.scale = lastScale * scaleChange;


        const rotationChange = currAngle - initialAngle;
        overlayState.rotation = lastRotation + rotationChange;


        const currCenter = getTouchCenter(e.touches[0], e.touches[1]);
        const dx = currCenter.x - lastTouchCenter.x;
        const dy = currCenter.y - lastTouchCenter.y;


        overlayState.x += dx;
        overlayState.y += dy;


        lastTouchCenter = currCenter;
      }
    }, { passive: false });


    canvas.addEventListener('touchend', e => {
      if (e.touches.length === 0) {
        isTouchDragging = false;
        canvas.style.cursor = 'grab';
      }
    }, { passive: false });


    // Mouse drag fallback for desktop
    canvas.addEventListener('mousedown', e => {
      if (!isOverlayLoaded) return;
      const pos = getPointerPos(e);
      const ow = overlayImage.width * overlayState.scale;
      const oh = overlayImage.height * overlayState.scale;
      if (pointInRotatedRect(pos.x, pos.y, overlayState.x, overlayState.y, ow, oh, overlayState.rotation)) {
        isDragging = true;
        overlayState.dragStartX = pos.x;
        overlayState.dragStartY = pos.y;
        overlayState.lastX = overlayState.x;
        overlayState.lastY = overlayState.y;
        canvas.style.cursor = 'grabbing';
      }
    });
    window.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const pos = getPointerPos(e);
      overlayState.x = overlayState.lastX + (pos.x - overlayState.dragStartX);
      overlayState.y = overlayState.lastY + (pos.y - overlayState.dragStartY);
    });
    window.addEventListener('mouseup', e => {
      if (isDragging) {
        isDragging = false;
        canvas.style.cursor = 'grab';
      }
    });


    switchBtn.addEventListener('click', () => {
      usingFrontCamera = !usingFrontCamera;
      updateCameraButtonText();
      startCamera();
    });


    captureBtn.addEventListener('click', () => {
      if (!video || video.videoWidth === 0 || video.videoHeight === 0) {
        alert('Video not ready');
        return;
      }
      const videoAspect = video.videoWidth / video.videoHeight;
      const canvasAspect = canvas.width / canvas.height;
      let drawWidth, drawHeight, offsetX, offsetY;
      if (canvasAspect > videoAspect) {
        drawHeight = canvas.height;
        drawWidth = drawHeight * videoAspect;
        offsetX = (canvas.width - drawWidth) / 2;
        offsetY = 0;
      } else {
        drawWidth = canvas.width;
        drawHeight = drawWidth / videoAspect;
        offsetX = 0;
        offsetY = (canvas.height - drawHeight) / 2;
      }
      const offCanvas = document.createElement('canvas');
      offCanvas.width = drawWidth;
      offCanvas.height = drawHeight;
      const offCtx = offCanvas.getContext('2d');
      offCtx.save();
      if (usingFrontCamera) {
        offCtx.translate(drawWidth, 0);
        offCtx.scale(-1, 1);
      }
      offCtx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, drawWidth, drawHeight);
      offCtx.restore();

      const overlayX = overlayState.x - offsetX;
      const overlayY = overlayState.y - offsetY;
      const ow = overlayImage.width * overlayState.scale;
      const oh = overlayImage.height * overlayState.scale;

      offCtx.save();
      offCtx.translate(overlayX + ow / 2, overlayY + oh / 2);
      offCtx.rotate(overlayState.rotation * Math.PI / 180);
      offCtx.translate(-ow / 2, -oh / 2);
      offCtx.drawImage(overlayImage, 0, 0, ow, oh);
      offCtx.restore();

      offCanvas.toBlob(blob => {
        if (!blob) {
          alert('Capture failed: empty image.');
          return;
        }
        const url = URL.createObjectURL(blob);
        window.open(url, '_blank');
      }, 'image/png');
    });


    window.addEventListener('resize', () => {
      detectDeviceAndToggleContainers();
      if (video && video.videoWidth) resizeCanvas();
    });



    detectDeviceAndToggleContainers();

  </script>
</body>
</html>
